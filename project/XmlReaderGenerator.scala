import java.io.File
import sbt._
import Keys._
import NetLogoBuild.autogenRoot

import scala.xml.{ Attribute, Elem, Node, NodeSeq, Text, XML }

object XmlReaderGenerator {
  lazy val parserSettings = Seq(sourceGenerators in Compile += coreTask.taskValue)
  lazy val bspaceSettings = Seq(sourceGenerators in Compile += bspaceTask.taskValue)

  // Big list of TODOs:
  //
  // * Remove hardcoded per-file imports in favor of additionalImports (in appInfo)
  // * generalize all sequence readers to use chain readers (doesn't work, not sure why)
  // * The names for methods / helper classes could be improved
  // * The code in this file is poorly organized and needs to be refactored
  // * Put autogenerated warning at top of file
  // * Potentially - move boilerplate to separate text file

  lazy val coreTask =
    Def.task {
      /*
      // Note: this is only suitable for a single file at the moment, but could probably be adapted to make several readers
      val cachedEvents =
        FileFunction.cached(streams.value.cacheDirectory / "xmlReader", inStyle = FilesInfo.hash, outStyle = FilesInfo.hash) {
          (in: Set[File]) =>
            Set(generator(streams.value.log.info(_),
              autogenRoot.value / "fileformat" / "netlogo.xsd",
              (sourceManaged in Compile).value,
              "org.nlogo.core.model"))
        }
      cachedEvents(Set(autogenRoot.value / "fileformat" / "netlogo.xsd")).toSeq
      */

     Seq(
       generator(streams.value.log.info(_),
         autogenRoot.value / "fileformat" / "netlogo.xsd",
         (sourceManaged in Compile).value,
         "org.nlogo.core.model",
         "Widget",
         "import org.nlogo.core.{ LogoList, Widget }",
         "org.nlogo.core",
         identity),
       generator(streams.value.log.info(_),
         autogenRoot.value / "fileformat" / "netlogo.xsd",
         (sourceManaged in Compile).value,
         "org.nlogo.core.model",
         "HubNetWidget",
         "import org.nlogo.core.{ LogoList, Widget }",
         "org.nlogo.core",
         identity),
       generator(streams.value.log.info(_),
         autogenRoot.value / "fileformat" / "netlogo.xsd",
         (sourceManaged in Compile).value,
         "org.nlogo.core.model",
         "linkShape",
         "",
         "org.nlogo.core",
         {(s: String) => s"XmlShape.coerceLinkShape($s)"}),
       generator(streams.value.log.info(_),
         autogenRoot.value / "fileformat" / "netlogo.xsd",
         (sourceManaged in Compile).value,
         "org.nlogo.core.model",
         "turtleShape",
         "",
         "org.nlogo.core",
         {(s: String) => s"XmlShape.coerceVectorShape($s)"})
     )
    }

    lazy val bspaceTask =
      Def.task {
        Seq(
          generator(streams.value.log.info(_),
            autogenRoot.value / "fileformat" / "netlogo.xsd",
            (sourceManaged in Compile).value,
            "org.nlogo.fileformat",
            "experiment",
            "import org.nlogo.core.{ LogoList, model},\n  model.{ Element, ElementFactory, InvalidElement, ParseError, UnknownElementType, XmlReader }\nimport org.nlogo.api.RefValueSet",
            "org.nlogo.api",
            identity),
          generator(streams.value.log.info(_),
            autogenRoot.value / "fileformat" / "netlogo.xsd",
            (sourceManaged in Compile).value,
            "org.nlogo.fileformat",
            "modelSettings",
            "import org.nlogo.core.model.{ Element, ElementFactory, InvalidElement, ParseError, UnknownElementType, XmlReader }",
            "org.nlogo.api",
            identity),
          generator(streams.value.log.info(_),
            autogenRoot.value / "fileformat" / "netlogo.xsd",
            (sourceManaged in Compile).value,
            "org.nlogo.fileformat",
            "previewCommands",
            "import org.nlogo.core.model.{ Element, ElementFactory, InvalidElement, ParseError, UnknownElementType, XmlReader }",
            "org.nlogo.api",
            identity)
          )
      }

    def generator(
      log:               String => Unit,
      source:            File,
      dir:               File,
      ppackage:          String,
      definingType:      String,
      additionalImports: String,
      importBase:        String,
      coerceWrite:       String => String): File = {

      val allComplexTypes = parseFile(source)

      val namedTopTypes: Seq[(String, String)] =
        allComplexTypes.get(definingType)
          .flatMap { ct =>
            ct.content.elements match {
              case Choice(elems, _, _, _) => Some(elems.collect {
                case SpecifiedElement(name, _, _, DataType.DeferredType(tName), _, _, _) =>
                  (name -> tName)
                case ElementReference(tName, _, _, _, _) =>
                  (tName -> tName)
              }.toSeq)
                case _ => Some(Seq(definingType -> definingType))
            }
          }.getOrElse(throw new Exception(s"Invalid root element $definingType"))

      val baseType = allComplexTypes(definingType).klassName

      val fileName = allComplexTypes(definingType).fileName.getOrElse(definingType.capitalize + "Xml")

      val topTypes = namedTopTypes.map(_._2)

      def elemsRequiringReaders(acc: Set[String], toVisit: Seq[String]): Set[String] = {
        if (toVisit.isEmpty) acc
        else if (acc.contains(toVisit.head)) elemsRequiringReaders(acc, toVisit.tail)
        else {
          val visiting = toVisit.head
          val newToVisit =
            allComplexTypes(visiting).content.elements.typesReferenced.filterNot(tName => acc.contains(tName)) - visiting
          elemsRequiringReaders(acc + visiting, toVisit ++ newToVisit)
        }
      }

      val elementsRequiringReaders = elemsRequiringReaders(Set.empty[String], topTypes)

      val complexTypeSpecs =
        allComplexTypes
          .filter(t => elementsRequiringReaders.contains(t._1))
          .map(_._2)
          .map(ct => ct.copy(isTopType = topTypes.contains(ct.name)))
          .toSeq

      val file = ppackage.split('.').foldLeft(dir)(_ / _) / s"${fileName}.scala"
      log("creating: " + file)

      val codeString = new StringBuilder()
      def append(s: String) = codeString.append(s + "\n")

      implicit val typesMap = complexTypeSpecs.map(t => t.name -> t).toMap

      append(s"package $ppackage")

      val classTree: Seq[Either[String, (String, String)]] =
        complexTypeSpecs.flatMap(_.importNames).map {
          case i =>
            if (! i.contains(".")) Left(i)
            else {
              val parts = i.split("\\.")
              Right(parts.head, parts.tail.mkString(""))
            }
        }
      val initialImports = classTree.map(_.fold(identity, _._1))
      val followImports: Seq[(String, Seq[String])] = {
        val subroots = classTree.flatMap(_.fold(_ => Seq(), t => Seq(t._1))).distinct
        val subrootMap: Map[String, Seq[String]] = subroots.map(r => r -> Seq()).toMap
        classTree.foldLeft(subrootMap) {
          case (acc, Left(_)) => acc
          case (acc, Right((r, n))) => acc + (r -> (acc(r) :+ n))
        }.toSeq
      }
      append(additionalImports)
      if (initialImports.nonEmpty) {
        append(s"import ${importBase}.${initialImports.distinct.mkString("{ ", ", ", " }")}${if (followImports.nonEmpty) "," else ""}")
        followImports
          .map { case (root, klassNames) => s"  ${root}.${klassNames.mkString("{ ", ", ", " }")}" }
          .foreach(append)
      }
      append("import cats.Apply")
      append("import cats.data.Validated, Validated.{ Valid, Invalid }")

      append("")
      append(s"object ${fileName} {")
      append(s"  trait Reader { def read(xml: Element): Validated[ParseError, ${baseType}] }")
      append(s"  trait Writer[W <: ${baseType}] { def write(${baseType.toLowerCase}: W, factory: ElementFactory): Element }")

      complexTypeSpecs.map(generateComplexTypeReader(typesMap)).foreach(append)
      append("  val readers = Map[String, Reader](")
      append(namedTopTypes
        .map { case (name, tpe) => s"""    "${name}" -> new ${tpe.name.capitalize}Reader("${name}")"""}
        .mkString(",\n"))
      append("  )")

      append(s"  def read(xml: Element): Validated[ParseError, ${baseType}] = {")
      append("    readers.get(xml.tag).map(_.read(xml))")
      append("     .getOrElse(Invalid(UnknownElementType(Seq(xml.tag))))")
      append("  }")

      append("")

      complexTypeSpecs.map(generateComplexTypeWriter(typesMap)).foreach(append)
      append(s"  def write(${baseType.toLowerCase}: ${baseType}, factory: ElementFactory): Element = {")
      matchCase(coerceWrite(baseType.toLowerCase),
        generateComplexTypeWriteMatches(complexTypeSpecs, namedTopTypes),
        indentLevel = 4).foreach(append)
      append("  }")

      append("}")

      IO.write(file, codeString.toString)
      file
    }

    // AttributeGroup represents an xml schema attribute group
    case class AttributeGroup(name: String, attributes: Seq[SpecifiedAttribute])

    case class SpecifiedAttribute(name: String,
      fieldName: String,
      tpe: DataType,
      fieldTpe: DataType,
      required: Boolean,
      default: Option[String]) {
        def isOption = ! required && default.isEmpty
    }

    // complexType represents a fully-formed complexType declaration
    case class ComplexType(name: String, isTopType: Boolean, content: ComplexTypeContent, fileName: Option[String] = None) {
      def importNames = content.importNames
      def klassName = content.klassName
      def constructorName = content.constructorName
      def typeName = content.typeName

      def constructor: String = content.constructorName
    }

    case class ComplexTypeContent(
      attributes: Seq[SpecifiedAttribute],
      elements: ComplexTypeElements,
      klassName: String,
      isPassThrough: Boolean,
      constructorName: String,
      singletonClass: Boolean,
      importNames: Seq[String] = Seq()) {
        def typeName: String = if (singletonClass) s"${klassName}.type" else klassName
      }

    sealed trait DataType {
      def attributeReaderName: Option[String]
      def className: String
      def resolvedType(implicit types: Map[String, ComplexType]): String =
        this match {
          case DataType.DeferredType(name) => types(name).klassName
          case other => other.className
        }
      def defaultValue(defaultString: String): String = defaultString
    }

    object DataType {
      def fromName(s: String): DataType = {
        val namesToType = Map[String, DataType](
          "xsd:boolean"            -> Boolean,
          "svg:ColorType"          -> Color,
          "svg:PointsType"         -> Points,
          "xsd:integer"            -> Integer,
          "xsd:positiveInteger"    -> Integer,
          "xsd:nonNegativeInteger" -> Integer,
          "xsd:string"             -> String,
          "xsd:double"             -> Double,
          "BigDecimal"             -> BigDecimal,
          "svg:StrokeDashArrayValueType" -> DashArray
        )

        namesToType.getOrElse(s, DeferredType(s))
      }
      case object Boolean extends DataType {
        val attributeReaderName = Some("booleanReader")
        val className = "Boolean"
      }
      case object BigDecimal extends DataType {
        val attributeReaderName = Some("bigDecimalReader")
        val className = "BigDecimal"
      }
      case object Character extends DataType {
        val attributeReaderName = Some("characterReader")
        val className = "Char"
      }
      case object Color extends DataType {
        val attributeReaderName = Some("colorReader")
        val className = "RgbColor"
      }
      case object DashArray extends DataType {
        val attributeReaderName = Some("dashArrayReader")
        val className = "Seq[Float]"
      }
      case object Points extends DataType {
        val attributeReaderName = Some("pointsReader")
        val className = "Seq[(Int, Int)]"
      }
      case object Double extends DataType {
        val attributeReaderName = Some("doubleReader")
        val className = "Double"
      }
      case object Integer extends DataType {
        val attributeReaderName = Some("intReader")
        val className = "Int"
      }
      case object String extends DataType {
        val attributeReaderName = Some("stringReader")
        val className = "String"
        override def defaultValue(defaultString: String): String = s""""$defaultString""""
      }
      case class Boxed(base: DataType) extends DataType {
        val attributeReaderName =
          base match {
            case DataType.Double => Some("boxedDoubleReader")
            case _ => None
          }
        val className =
          base match {
            case DataType.Boolean => "java.lang.Boolean"
            case DataType.Double  => "java.lang.Double"
            case _                => "AnyRef"
          }
      }
      case class RestrictionType(base: DataType, resultType: String, restriction: Restriction) extends DataType {
        val attributeReaderName = {
          restriction match {
            case Restriction.Enum(options) =>
              val enumMap = options.map {
                case (k, v) => s""""$k" -> $v"""
              }.mkString("Map(", ", ", ")")
              Some(s"enumReader[$resultType](${enumMap})")
            case _ => None
          }
        }
        val className = resultType
        override def defaultValue(defaultString: String): String =
          restriction match {
            case Restriction.Enum(options) =>
              options.find(_._1 == defaultString).map(_._2)
                .getOrElse(throw new Exception(s"invalid default value: $defaultString"))
            case _ => super.defaultValue(defaultString)
          }
      }
      case class DeferredType(name: String) extends DataType {
        val attributeReaderName = None
        val className = "AnyRef"
      }
      case class NestedComplexType(content: ComplexTypeContent) extends DataType {
        val attributeReaderName = None
        val className = content.klassName
      }
    }

    sealed trait Restriction
    object Restriction {
      case class Enum(options: Seq[(String, String)]) extends Restriction
    }

    sealed trait SequenceChild {
      def typesReferenced: Set[String]
    }

    // Element definitions
    sealed trait ElementDefinition extends SequenceChild {
      def min: Int
      def max: Option[Int]
      def isOptional: Boolean
      def default: Option[String]
      def typesReferenced: Set[String]
      def resolved(implicit types: Map[String, ComplexType]): SpecifiedElement = {
        this match {
          case s: SpecifiedElement => s
          case c: ElementReference =>
            val ct = types(c.refName)
            SpecifiedElement(ct.name, c.fieldName.getOrElse(ct.name), None, DataType.DeferredType(ct.name), c.min, c.max, None)
        }
      }
    }
    case class SpecifiedElement(
      name: String,
      fieldName: String,
      additionalField: Option[String],
      tpe: DataType,
      min: Int,
      max: Option[Int],
      default: Option[String]) extends ElementDefinition {
        def isOptional = min == 0 && max == Some(1) && default.isEmpty
        def elementReader: String =
          if (min == 0) s"""XmlReader.optionalElementReader(${name.quoted})""" // optional
          else          s"""XmlReader.allElementReader(${name.quoted})"""      // single
        def content(implicit types: Map[String, ComplexType]): Option[ComplexTypeContent] =
          tpe match {
            case DataType.NestedComplexType(c) => Some(c)
            case DataType.DeferredType(t) => types.get(name).map(_.content)
            case _ => None
          }
        def typesReferenced =
          tpe match {
            case DataType.DeferredType(tName) => Set(tName)
            case DataType.NestedComplexType(content) => content.elements.typesReferenced
            case _ => Set.empty[String]
          }
      }
    case class ElementReference(refName: String, fieldName: Option[String], min: Int, max: Option[Int], default: Option[String]) extends ElementDefinition {
      def isOptional = min == 0 && max == Some(1)
      def typesReferenced = Set(refName)
    }

    // Complex types contain one of all, choice, sequence, or simpleContent
    sealed trait ComplexTypeElements {
      def elements: Seq[ElementDefinition]
      def representsSequence: Boolean = false
      def typesReferenced: Set[String] = elements.flatMap(_.typesReferenced).toSet
    }
    case class All(elements: Seq[ElementDefinition]) extends ComplexTypeElements
    case class Choice(elements: Seq[ElementDefinition], fieldName: String, klassName: Option[String], isPassThrough: Boolean = false) extends ComplexTypeElements with SequenceChild {
      def constructor(s: String): String =
        if (klassName.exists(_ == "AnyRef") || isPassThrough) s
        else                                                 s"${klassName.get}($s)"
    }

    case class Sequence(children: Seq[SequenceChild], fieldName: Option[String], variadic: Boolean) extends ComplexTypeElements {
      def elements =
        children.collect {
          case elem: ElementDefinition => elem
        }
      override def representsSequence = children.length == 1
      override def typesReferenced: Set[String] = children.flatMap(_.typesReferenced).toSet
    }
    case class SimpleContent(baseType: DataType, fieldName: String) extends ComplexTypeElements {
      def elements = Seq()
    }

    // these classes represent expression values about to be written
    sealed trait ExpressedType
    case class ArbitraryType(name: String) extends ExpressedType
    case class SpecifiedType(dataType: DataType) extends ExpressedType
    case object ElementType extends ExpressedType
    case object AttributeType extends ExpressedType

    abstract class ExpressedValue(tpe: ExpressedType) {
      def applyTo(f: String => String, tpe: ExpressedType = tpe): ExpressedValue
      def renderValue: String
    }

    case class ExpressedAtom(exp: String, tpe: ExpressedType) extends ExpressedValue(tpe) {
      def applyTo(f: String => String, tpe: ExpressedType = tpe): ExpressedValue =
        new ExpressedAtom(f(exp), tpe)
      def renderValue: String = exp
    }

    class ExpressedAtomWithDefault(exp: String, val defaultExp: String, tpe: ExpressedType)
    extends ExpressedAtom(exp, tpe) {
      override def applyTo(f: String => String, tpe: ExpressedType = tpe): ExpressedValue =
        new ExpressedAtomWithDefault(f(exp), defaultExp, tpe)
      override def toString = s"ExpressedAtomWithDefault(${exp}, ${defaultExp}, ${tpe})"
    }

    case class ExpressedOption(exp: String, tpe: ExpressedType, fs: Seq[String => String] = Seq())
      extends ExpressedValue(tpe) {
      def applyTo(f: String => String, tpe: ExpressedType = tpe): ExpressedValue =
        new ExpressedOption(exp, tpe, fs :+ f)
      def renderValue: String =
        (exp +: (fs.map(f => s"map(v => ${f("v")})"))).mkString(".")
    }

    case class ExpressedSequence(exp: String, tpe: ExpressedType, fs: Seq[String => String] = Seq())
      extends ExpressedValue(tpe) {
      def applyTo(f: String => String, tpe: ExpressedType = tpe): ExpressedValue =
        new ExpressedSequence(exp, tpe, fs :+ f)
      def renderValue: String =
        (exp +: (fs.map(f => s"map(v => ${f("v")})"))).mkString(".")
    }

    // these classes represent program statements
    case class Decl(name: String, assignedValue: String)
    case class Assignment(readExpression: String, fieldNames: Seq[String], varName: String, variadic: Boolean = false)
    case class CoercionFunction(name: String, inputs: Seq[(String, String)], outputType: String, lines: Seq[String])

    implicit class RichNodeSeq(nodeSeq: NodeSeq) {
      def appInfo(propName: String): Option[String] =
        (nodeSeq \ "annotation" \ "appinfo" \ s"@$propName").headOption.map(_.text)
    }

    implicit class RicherString(s: String) {
      def quoted: String =
        if (s.nonEmpty && s.head == '"' && s.last == '"')
          s
        else
          s""""$s""""

      def scalaSafe: String =
        s.replaceAllLiterally("final", "_final").replaceAllLiterally("-", "")

      def decapitalize: String =
        if (s.isEmpty) s
        else Character.toLowerCase(s.head) + s.tail
    }

    trait DeclGenerator {
      def methodIndentLevel: Int
      var decls: Seq[Decl] = Seq.empty[Decl]
      def declStrings: Seq[String] =
        decls.map(d => (" " * (methodIndentLevel + 2)) + s"val ${d.name} = ${d.assignedValue}")
      def declare(name: String, assignedValue: String): Unit =
        decls = decls :+ Decl(name, assignedValue)
      def declare(decl: Decl): Unit =
        decls = decls :+ decl
    }

    trait AssignmentGenerator {
      def methodIndentLevel: Int
      def complexType: ComplexType
      var assignmentMap: Map[String, Assignment] = scala.collection.immutable.ListMap.empty[String, Assignment]
      def assignment(readExpression: String, fieldNames: Seq[String], varName: String, variadic: Boolean = false): Unit = {
        assignmentMap = assignmentMap + (varName -> Assignment(readExpression, fieldNames, varName.scalaSafe, variadic))
      }
      def assignments = assignmentMap.values.toSeq
      def assignmentStrings: Seq[String] = {
        val renderedAssignments =
          assignments.flatMap(a => a.fieldNames.map { f =>
            if (a.variadic) s"${f} = ${a.varName}: _*"
            else s"${f} = ${a.varName}"
          }).mkString(", ")

        if (assignments.isEmpty && complexType.content.isPassThrough) Seq(s"null // ${complexType.toString}")
        else if (assignments.isEmpty && complexType.content.singletonClass) Seq(s"Valid(${complexType.content.klassName})")
        else if (assignments.isEmpty) Seq("null")
        else if (complexType.content.isPassThrough) Seq((" " * (methodIndentLevel + 2)) + assignments.head.readExpression)
        else {
          val addPath =
            if (complexType.content.elements.isInstanceOf[Choice]) ""
            else s""".bimap(_.atPath(name), identity _)"""
          val applyMap =
            if (assignments.length == 1) "Apply[ReadValidation#l].map"
            else s"Apply[ReadValidation#l].map${assignments.length}"
          Seq(
            s"$applyMap(",
            s"  ${assignments.map(_.readExpression).mkString(", ")}",
             ") {",
            s"  case (${assignments.map(_.varName).mkString(", ")}) =>",
            s"    ${complexType.constructorName}(${renderedAssignments})",
            s"  }$addPath").map(l => (" " * methodIndentLevel) + l)
        }

      }
    }

    trait CoercionGenerator {
      def methodIndentLevel: Int
      var coercions = Seq.empty[CoercionFunction]
      def coerce(name: String, inputs: Seq[(String, String)], outputType: String, lines: Seq[String]): Unit =
        coercions = coercions :+ CoercionFunction(name, inputs, outputType, lines)
      def coercionFunctionToString(indentLevel: Int)(f: CoercionFunction): Seq[String] = {
        ((s"def ${f.name}(${f.inputs.map(t => s"${t._1}: ${t._2}").mkString(", ")}): ${f.outputType} = {" +: f.lines.map(indent(2))) :+
          "}").map(indent(indentLevel))
      }
      def coercionStrings = coercions.flatMap(coercionFunctionToString(methodIndentLevel))
    }

    trait WriterComponentGenerator {
      def methodIndentLevel: Int
      def elementName: String
      var writers = Seq.empty[String]
      def write(s: String): Unit = {
        writers = writers :+ s
      }
      def write(exp: ExpressedValue, name: String = ""): Unit = {
        val stringToWrite =
          exp match {
            case awd: ExpressedAtomWithDefault =>
              s""".withDefaultAttribute("${name}", ${awd.renderValue}, ${awd.defaultExp})"""
            case a@ExpressedAtom(e, ElementType)        => s".withElement(${a.renderValue})"
            case o@ExpressedOption(e, ElementType, _)   => s".withOptionalElement(${o.renderValue})"
            case s@ExpressedSequence(e, ElementType, _) => s".withElementList(${s.renderValue})"
            case o@ExpressedOption(e, AttributeType, _) => s".withOptionalAttribute(${o.renderValue})"
              s""".withOptionalAttribute("${name}", ${o.renderValue})"""
            case a@ExpressedAtom(e, AttributeType)      =>
              s""".withAttribute("${name}", ${a.renderValue})"""
            case other => throw new Exception(s"unable to write: $exp")
          }
        write(stringToWrite)
      }
      def writerStrings =
        indent(methodIndentLevel + 2)(s"""factory.newElement(name)""") +:
          writers.map(indent(methodIndentLevel + 4)) :+
          indent(methodIndentLevel + 4)(".build")
    }

    class ReaderGenerator(val complexType: ComplexType, val methodIndentLevel: Int = 2) extends DeclGenerator with AssignmentGenerator {
      val name = s"""val name: String = "${complexType.name}""""
      val base =
        if (complexType.isTopType) "Reader"
        else s"XmlReader[Element, ${complexType.typeName}]"

      val widgetName = complexType.name.capitalize

      def buildReader: String =
        s"""|  class ${widgetName}Reader(${name}) extends ${base} {
            |    type ReadValidation = ({ type l[A] = Validated[ParseError, A] })
            |    def read(xml: Element): Validated[ParseError, ${complexType.typeName}] = {
            |      // println(xml)
            |${declStrings.mkString("\n")}
            |${assignmentStrings.mkString("\n")}
            |    }
            |  }""".stripMargin
    }

    class WriterGenerator(val complexType: ComplexType, val methodIndentLevel: Int = 2) extends DeclGenerator with CoercionGenerator with WriterComponentGenerator {
      val widgetName = complexType.name.capitalize
      val elementName = complexType.name
      val base =
        if (complexType.isTopType) s"extends Writer[${complexType.typeName}] "
        else s""

      var additionalWriters = Seq.empty[WriterGenerator]

      def withAdditionalWriter(w: WriterGenerator) =
        additionalWriters = additionalWriters :+ w

      def buildWriter: String =
        s"""|  class ${widgetName}Writer(val name: String = ${elementName.quoted}) ${base}{
            |${coercionStrings.mkString("\n")}
            |    def write(w: ${complexType.typeName}, factory: ElementFactory): Element = {
            |${declStrings.mkString("\n")}
            |${writerStrings.mkString("\n")}
            |    }
            |  }""".stripMargin ++ additionalWriters.map(_.buildWriter).mkString("\n\n", "\n\n", "")
    }

    def indent(i: Int)(s: String): String =
      (" " * i) + s

    def matchCase(e: String, cases: Seq[(String, String, String)], indentLevel: Int = 0): Seq[String] =
      (s"$e match {" +: cases.map(matchCaseString).map(indent(2)) :+ "}").map(indent(indentLevel))

    def matchCaseString(t: (String, String, String)): String =
      t match {
        case ("", tpeName, exp) => s"case $tpeName => $exp" // case objects
        case (v, tpeName, exp) => s"case $v: $tpeName => $exp"
      }

    def generateAttributeReader(attr: SpecifiedAttribute): String = {
      def conversion(sourceTpe: DataType, destTpe: DataType): String = {
        (sourceTpe, destTpe) match {
          case (DataType.Color, DataType.Double) => "XmlReader.rgbColorToDouble"
          case _ => throw new Exception(s"unsupported conversion from ${sourceTpe} to ${destTpe}")
        }
      }
      val readerName =
        attr.tpe.attributeReaderName.getOrElse(throw new Exception(s"unsupported attribute type: ${attr.tpe}"))
      val defaultClause = attr.default.map { d =>
        val defaultValue = attr.tpe.defaultValue(d)
        s".withDefault($defaultValue)"
      }.getOrElse("")
      val base = s"""XmlReader.${readerName}("${attr.name}")${defaultClause}"""
      if (attr.fieldTpe != attr.tpe) s"${base}.map(${conversion(attr.tpe, attr.fieldTpe)})"
      else base
    }

    def processReadElement(elemName: String, min: Int, max: Option[Int], default: Option[String], tpe: DataType)(implicit types: Map[String, ComplexType], generator: ReaderGenerator): String = {
      (min, max, default, tpe) match {
        case (0, Some(1), None, DataType.String)    => ".map(_.flatMap(e => XmlReader.textToOption(XmlReader.childText(e))))"
        case (0, Some(1), Some(defaultString), DataType.String) =>
          val default = tpe.defaultValue(defaultString)
          s".map(_.map(e => XmlReader.childText(e)).getOrElse(${default}))"
        case (0, Some(1), None, DataType.DeferredType(name)) =>
          s".flatMap(_.map(new ${name.capitalize}Reader(${elemName.quoted}).read))"
        case (0, Some(1), Some(defaultString), DataType.DeferredType(name)) =>
          val default = tpe.defaultValue(defaultString)
          s".flatMap(_.map(new ${name.capitalize}Reader(${elemName.quoted}).read).getOrElse(Valid($default)))"
        case (0, Some(1), Some(defaultString), other) =>
          val reader = stringToType(elemName.quoted, other)
          val default = tpe.defaultValue(defaultString)
          s".flatMap[${tpe.className}](_.map(e => XmlReader.childText(e)).map(${reader}).getOrElse(Valid(${default})))"
        case (_, _, _, DataType.String)             => ".map(XmlReader.childText _)"
        case (_, _, _, DataType.DeferredType(name)) =>
          s".flatMap(new ${name.capitalize}Reader(${elemName.quoted}).read)"
        case (_, _, _, DataType.NestedComplexType(content)) =>
          generateContentReader(elemName, elemName.quoted, content)
          s".flatMap(${generator.decls.last.name}.read _) // ${content.toString}"
        case (_, _, _, other)                       => s".map(XmlReader.childText _).flatMap(${stringToType(elemName.quoted, other)})"
        case _ => throw new Exception("Don't know how to read element: " + elemName + " of type " + tpe)
      }
    }

    def stringToType(elemName: String, childType: DataType) = {
      val invalidation = s"""Invalid(new InvalidElement(Seq(), ${elemName}, s))"""
      def conversion(tpe: DataType): (String => String) =
        tpe match {
          case DataType.Boolean  => { (varName: String) => s"$varName.toBoolean" }
          case DataType.Double   => { (varName: String) => s"$varName.toDouble" }
          case DataType.Integer  => { (varName: String) => s"$varName.toInt" }
          case DataType.Boxed(t) => { (varName: String) => s"${t.className}.box(${conversion(t)(varName)})" }
          case other             => throw new Exception("Unsupported stringToType conversion for: " + other)
        }
      s"{ (s: String) => try { Valid(${conversion(childType)("s")}) } catch { case e: Exception => $invalidation } }"
    }

    def generateSingleElementReader(elemName: String, min: Int, max: Option[Int], default: Option[String], tpe: DataType)(implicit types: Map[String, ComplexType], generator: ReaderGenerator): String = {
      val processMatch = processReadElement(elemName, min, max, default, tpe)

      s"""XmlReader.elemReader(${elemName})""" + processMatch
    }

    // returns name of choice reader
    def declareChoiceReader(c: Choice, name: String)(implicit types: Map[String, ComplexType], generator: ReaderGenerator): String = {
      val subReaderDecls = c.elements.map(declareRequiredElementReader)
      generator.declare(s"${name}ChoiceReader",
        s"""XmlReader.choiceElementReader(Seq(${subReaderDecls.mkString(", ")})).map(e => ${c.constructor("e")})""")
      s"${name}ChoiceReader"
    }

    def declareRequiredElementReader(e: ElementDefinition)(implicit types: Map[String, ComplexType], generator: ReaderGenerator): String =
      e match {
        case se: SpecifiedElement =>
          generator.declare(s"${se.name}Reader", generateSingleElementReader(se.name.quoted, se.min, se.max, se.default, se.tpe))
          s"${se.name}Reader"
        case ctr: ElementReference =>
          s"new ${ctr.refName.capitalize}Reader()"
      }

    def generateContentReader(name: String, tagName: String, content: ComplexTypeContent)(implicit types: Map[String, ComplexType], generator: ReaderGenerator): Unit = {
      content.attributes.map { attr =>
        generator.declare(s"${attr.name.scalaSafe}AttributeReader", generateAttributeReader(attr))
        if (! content.isPassThrough) {
          generator.assignment(s"${attr.name.scalaSafe}AttributeReader.read(xml)", Seq(attr.fieldName), attr.name.scalaSafe)
        }
      }
      content.elements match {
        case All(es) =>
          content.elements.elements.map(_.resolved).foreach {
            elem =>
              val processMatch = processReadElement(elem.name, elem.min, elem.max, elem.default, elem.tpe)
              val readerName = s"${elem.name}Reader"
              generator.declare(readerName, elem.elementReader + processMatch)
              val varNames = Seq(elem.fieldName) ++ elem.additionalField.map(f => Seq(f)).getOrElse(Seq.empty[String])
              generator.assignment(s"${readerName}.read(xml)", varNames, elem.name)
          }
        case c: Choice =>
          val readerName = declareChoiceReader(c, name)
          generator.assignment(s"${readerName}.read(xml)", Seq(c.fieldName), name)
        case Sequence(Seq(e), fieldName, variadic) =>
          val subreader = e match {
            case e: ElementDefinition => declareRequiredElementReader(e)
            case c: Choice            => declareChoiceReader(c, name)
          }
          val finalFieldName = fieldName.getOrElse(e match {
            case se: SpecifiedElement => se.fieldName
            case ctr: ElementReference => ctr.resolved.fieldName
            case c: Choice => name
          })
          val min = e match {
            case ed: ElementDefinition => ed.min
            case _ => 0
          }
          generator.declare(s"${name}SequenceReader",
            s"""XmlReader.sequenceElementReader(${tagName}, ${min}, ${subreader})""")
          generator.assignment(s"${name}SequenceReader.read(xml)", Seq(finalFieldName), name, variadic)
        case Sequence(es, fieldName, variadic) =>
          def chainReader(elemsToReadName: String, e: SequenceChild): String = {
            val subreader = e match {
              case e: ElementDefinition => declareRequiredElementReader(e)
              case c: Choice            => declareChoiceReader(c, name)
            }
            val min = e match {
              case ed: ElementDefinition => ed.min
              case _ => 0
            }
            val max = e match {
              case ed: ElementDefinition => ed.max.map(i => s"Some(${i.toString})").getOrElse("None")
              case _ => "None"
            }
            val fieldName = e match {
              case se: SpecifiedElement => se.fieldName
              case ctr: ElementReference => ctr.fieldName.getOrElse(ctr.resolved.fieldName)
              case c: Choice => name // <-- this seems bogus...
            }
            val thisReaderName = e match {
              case r: ElementReference => r.refName
              case e: SpecifiedElement => e.name
              case c: Choice => c.fieldName
            }
            val defaultClause = e match {
              case e: SpecifiedElement if e.default.nonEmpty =>
                s""".orElse(Valid(${e.tpe.defaultValue(e.default.get)}))"""
              case e: SpecifiedElement if e.content.exists(_.elements.representsSequence) =>
                s""".orElse(Valid(List()))"""
              case _ => ""
            }
            val postProcess =
              if (max == "Some(1)" && defaultClause.nonEmpty)
                s".andThen(s => XmlReader.validHead(s, ${thisReaderName.quoted}))${defaultClause}"
              else if (min == 1 && max == "Some(1)") ".map(_.head)"
              else ""
            generator.declare(s"${thisReaderName}ChainReader",
              s"""XmlReader.chainElementReader(${min}, ${max}, ${subreader})""")
            generator.declare(s"${thisReaderName}ChainResult", s"${elemsToReadName}.andThen(${thisReaderName}ChainReader.read _)")
            generator.assignment(s"${thisReaderName}ChainResult.map(_._1)${postProcess}", Seq(fieldName), fieldName)
            s"${thisReaderName}ChainResult.map(_._2)"
          }
          es.foldLeft(s"XmlReader.childrenElemReader.read(xml)") {
            case (toRead, e) => chainReader(toRead, e)
          }
        case SimpleContent(baseType: DataType, fieldName) =>
          generator.declare(s"${name}ContentReader", generateSingleElementReader("name", 1, Some(1), None, baseType))
          generator.assignment(s"${name}ContentReader.read(xml)", Seq(fieldName), fieldName)
      }
    }

    def generateComplexTypeWriter(typesMap: Map[String, ComplexType])(spec: ComplexType): String = {
      implicit val tpes = typesMap
      implicit val generator = new WriterGenerator(spec, 4)
      generateContentWriter(spec.content, "w")
      generator.buildWriter
    }

    def generateContentWriter(content: ComplexTypeContent, varName: String)(implicit types: Map[String, ComplexType], generator: WriterGenerator): Unit = {
      content.attributes.foreach(a =>
          generateAttributeWriter(a, if (content.isPassThrough) varName else s"${varName}.${a.fieldName}"))
      content.elements match {
        case SimpleContent(tpe, fieldName) =>
          generator.write(s".withText(${varName}.${fieldName}.toString)")
        case All(es) =>
          es.map(_.resolved)
            .map { e =>
              val variable = if (content.isPassThrough) varName else s"${varName}.${e.fieldName}"
              specifiedElementWriter(variable)(e)
            }
            .foreach(writer => generator.write(writer))
        case Sequence(es, _, _) =>
          def writeSeqElement(e: SequenceChild): Unit =
            e match {
              case e: ElementDefinition =>
                val resolvedElem = e.resolved
                if (resolvedElem.min == 1 && resolvedElem.max == Some(1)) {
                  val expressedValue = specifiedElementWriter(s"${varName}.${resolvedElem.fieldName}")(resolvedElem)
                  generator.write(expressedValue)
                } else if (resolvedElem.min == 0 && resolvedElem.max == Some(1) && resolvedElem.default.nonEmpty) {
                  val actualValue = s"${varName}.${resolvedElem.fieldName}"
                  val expressedValue = specifiedElementWriter(actualValue)(resolvedElem)
                  val expression = ExpressedOption(
                    s"if (${actualValue} != ${resolvedElem.tpe.defaultValue(resolvedElem.default.get)}) ${expressedValue.applyTo(v => s"Some($v)").renderValue} else None", ElementType)
                  generator.write(expression)
                } else {
                  val declaredName = s"${resolvedElem.fieldName}Elem"
                  val variable = if (content.isPassThrough) varName else s"${varName}.${resolvedElem.fieldName}"
                  val expressedSeq = ExpressedSequence(variable, SpecifiedType(resolvedElem.tpe))
                  val expressedElem = specificWriter(expressedSeq, e)
                  generator.write(expressedElem)
                }
              case c: Choice =>
                val fn = choiceCoercionFunction(c)
                generator.write(s".withElementList(${varName}.map(e => ${fn}(e, factory)).toSeq)")
            }
          es.foreach(writeSeqElement)
        case c: Choice =>
          val fn = choiceCoercionFunction(c)
          generator.write(s".withElement(${fn}(${varName}, factory))")
        case other =>
      }
    }

    private def choiceCoercionFunction(c: Choice)(implicit types: Map[String, ComplexType], generator: WriterGenerator): String = {
      val matchCases = c.elements.map { elem =>
        val resolvedElem = elem.resolved
        val className = resolvedElem.tpe.resolvedType
        resolvedElem.tpe match {
          case DataType.DeferredType(tName) if types(tName).content.singletonClass =>
            ("", className, specifiedElementWriter(className)(elem).renderValue)
          case _ =>
            (resolvedElem.name, className, specifiedElementWriter(resolvedElem.name)(elem).renderValue)
        }
      }
      val matchAccessor = if (c.isPassThrough) "v" else s"v.${c.fieldName}"
      generator.coerce(s"${c.fieldName}ToElem",
        Seq(("v", c.klassName.getOrElse("AnyRef")), ("factory", "ElementFactory")),
        "Element", matchCase(matchAccessor, matchCases))
      s"${c.fieldName}ToElem"
    }

    private def specifiedElementWriter(varName: String)(e: ElementDefinition)(implicit types: Map[String, ComplexType], generator: WriterGenerator): ExpressedValue = {
        if (e.min == 0 && e.default.nonEmpty) {
          val expressedValue = specificWriter(ExpressedAtom(varName, SpecifiedType(e.resolved.tpe)), e)
          ExpressedOption(
            s"if (${varName} != ${e.resolved.tpe.defaultValue(e.default.get)}) ${expressedValue.applyTo(v => s"Some($v)").renderValue} else None", ElementType)
        } else if (e.isOptional)
          specificWriter(ExpressedOption(varName, SpecifiedType(e.resolved.tpe)), e)
        else
          specificWriter(ExpressedAtom(varName, SpecifiedType(e.resolved.tpe)), e)
    }

    private def specificWriter(exp: ExpressedValue, e: ElementDefinition)(implicit types: Map[String, ComplexType], generator: WriterGenerator): ExpressedValue = {
      val elem = e.resolved
      val name = elem.name
      val tpe = elem.tpe
      def generateAndAddElement(text: String): String =
        s"""factory.newElement("${name}").withText(${text}).build"""
      def writeType(name: String, klassName: String)(varName: String): String =
        s"new ${name.capitalize}Writer(${elem.name.quoted}).write(${varName}.asInstanceOf[${klassName}], factory)"
      tpe match {
        case DataType.String                                    =>
          exp.applyTo(generateAndAddElement(_), ElementType)
        case DataType.Integer | DataType.Boxed(DataType.Boolean) =>
          exp.applyTo((s: String) => s"${s}.toString").applyTo(generateAndAddElement(_), ElementType)
        case DataType.Boxed(DataType.Double) =>
          exp
            .applyTo((s: String) => s"XmlReader.formatDouble(${s})")
            .applyTo(generateAndAddElement(_), ElementType)
        case DataType.DeferredType(tName)        =>
          exp.applyTo(writeType(tName, types(tName).typeName), ElementType)
        case DataType.NestedComplexType(content) =>
          val subTypeGenerator = new WriterGenerator(ComplexType(s"${name}", false, content), generator.methodIndentLevel)
          generator.withAdditionalWriter(subTypeGenerator)
          generateContentWriter(content, "w")(types, subTypeGenerator)
          exp.applyTo(writeType(name, content.klassName), ElementType)
        case other => throw new Exception(s"Don't know how to make writer for type $other")
      }
    }

    private def generateAttributeWriter(a: SpecifiedAttribute, varName: String)(implicit generator: WriterGenerator): Unit = {
      // generate coercion method
      a.tpe match {
        case DataType.RestrictionType(_, resultType, Restriction.Enum(options)) =>
          val typeName = resultType.toLowerCase.split('.').last
          val matchLines =
            s"${typeName} match {" +: options.map {
              case (stringValue, klassName) => s"""  case ${klassName} => "$stringValue""""
            } :+ "}"
          generator.coerce(s"${typeName}ToString", Seq((typeName, resultType)), "String", matchLines)
        case _ =>
      }

      def coerceVariable(v: String): String = {
        a.tpe match {
          case DataType.Color =>
            a.fieldTpe match {
              case DataType.Double => s"XmlReader.rgbColorToHex(XmlReader.doubleToRgbColor(${v}))"
              case _ => s"XmlReader.rgbColorToHex(${v})"
            }
          case DataType.DashArray => s"XmlReader.dashArrayToString(${v})"
          case DataType.RestrictionType(_, resultType, Restriction.Enum(options)) =>
            val typeName = resultType.toLowerCase.split('.').last
            // we want to do a case match here and map back to field name
            s"${typeName}ToString(${v})"
          case DataType.Points =>
            s"""${v}.map(t => t._1 + "," + t._2).mkString(" ")"""
          case DataType.Double => s"XmlReader.formatDouble(${v})"
          case _ => s"${v}.toString"
        }
      }

      val expressedValue =
        if (a.isOption) ExpressedOption(varName, AttributeType)
        else if (a.default.nonEmpty)
          new ExpressedAtomWithDefault(varName, coerceVariable(a.tpe.defaultValue(a.default.get)), AttributeType)
        else ExpressedAtom(varName, AttributeType)

      generator.write(expressedValue.applyTo(coerceVariable _, AttributeType), a.name)
    }

    def generateComplexTypeWriteMatches(complexTypeSpecs: Seq[ComplexType], namedTopTypes: Seq[(String, String)])(implicit types: Map[String, ComplexType]): Seq[(String, String, String)] = {
      def name(tpeName: String) =
        namedTopTypes.find(_._2 == tpeName).map(_._1).getOrElse(tpeName)
      val allWidgets = complexTypeSpecs.filter(_.isTopType)
      val typeGroups = allWidgets.groupBy(_.klassName)
      typeGroups.flatMap {
        case (klassName, cts) =>
          if (cts.length == 1) {
            val ct = cts.head
            // TODO: Special-casing PreviewCommands.Manual is a terrible hack
            val varName = if (klassName == "PreviewCommands.Manual") "" else ct.name.decapitalize
            val writtenName = if (klassName == "PreviewCommands.Manual") "PreviewCommands.Manual" else varName
            Seq((varName, ct.klassName, s"new ${ct.name.capitalize}Writer(${name(ct.name).quoted}).write(${writtenName}, factory)"))
          } else {
            val allResolvedElements: Seq[(ComplexType, Seq[SpecifiedElement])] =
              cts.map(ct => (ct, ct.content.elements.elements.map(_.resolved)))
            val initAccum: Seq[Seq[(SpecifiedElement, ComplexType)]] = {
              val (ct, els) = allResolvedElements.head
              els.map(el => Seq((el, ct)))
            }
            val elements: Seq[Seq[(SpecifiedElement, ComplexType)]] =
              allResolvedElements.tail.foldLeft(initAccum) {
                case (acc, (ct, els)) =>
                  (acc zip els.map(el => (el, ct))).map {
                    case (accEl, el) => accEl :+ el
                  }
                }
            val differingElement = elements.find(_.map(es => es._1.tpe).distinct.length > 1).get
            val differingElementFieldName = differingElement.head._1.fieldName
            val differingElementSubcases =
              differingElement.map {
                case (el, ct) =>
                  el.tpe match {
                    case DataType.DeferredType(tName) if (types(tName).content.singletonClass) =>
                      ("", el.tpe.resolvedType, s"new ${ct.name.capitalize}Writer(${name(ct.name).quoted}).write(${klassName.toLowerCase}, factory)")
                    case _ =>
                      (el.name, el.tpe.resolvedType, s"new ${ct.name.capitalize}Writer(${name(ct.name).quoted}).write(${klassName.toLowerCase}, factory)")
                  }
              }

            Seq((klassName.toLowerCase, klassName,
              matchCase(s"${klassName.toLowerCase}.${differingElementFieldName}", differingElementSubcases, 6).mkString("\n")))
          }
      }.toSeq
    }

    def generateComplexTypeReader(types: Map[String, ComplexType])(spec: ComplexType): String = {
      implicit val tpes = types
      implicit val generator = new ReaderGenerator(spec, 4)
      val name = if (spec.isTopType) spec.name.quoted else "name"
      generateContentReader(spec.name, name, spec.content)
      generator.buildReader
    }

  def parseFile(source: File): Map[String, ComplexType] = {
    val root = XML.loadFile(source)
    val allAttributeGroups = root.child.collect {
      case e@Elem("xsd", "attributeGroup", _, _, _*) => parseAttributeGroup(e.asInstanceOf[Elem])
    }
    val attributeGroupMap = allAttributeGroups.map(g => g.name -> g).toMap
    root.child.collect {
      case e@Elem("xsd", "complexType", Attribute("name", xml.Text(t), _), _, _*) => t ->
      parseComplexType(e.asInstanceOf[Elem], attributeGroupMap, false)
    }.toMap
  }

  def parseAttributeGroup(attributeGroupSpec: Elem): AttributeGroup = {
    val name = attributeGroupSpec.attributes("name").text
    val childElems = attributeGroupSpec.child.collect {
      case e@Elem("xsd", "attribute", _, _, _*) => parseSpecifiedAttribute(e.asInstanceOf[Elem])
    }
    AttributeGroup(name, childElems)
  }

  def parseTypeAttribute(e: Node): Option[DataType] = {
    e.attributes.get("type").flatMap(_.headOption).map(_.text).map(DataType.fromName).map {t =>
      val boxed = e.appInfo("boxed").map(_.toBoolean).getOrElse(false)
      if (boxed) DataType.Boxed(t) else t
    }
  }

  def parseSpecifiedAttribute(attributeElem: Elem): SpecifiedAttribute = {
    val name = attributeElem.attributes("name").text
    val tpe = parseTypeAttribute(attributeElem).getOrElse(nestedAttributeType(attributeElem))
    val required = attributeElem.attribute("use").exists(_.text == "required")
    val default = attributeElem.attribute("default").map(_.text)
    val fieldName = attributeElem.appInfo("fieldName").getOrElse(name)
    val fieldTpe = attributeElem.appInfo("fieldType").map(DataType.fromName).getOrElse(tpe)
    SpecifiedAttribute(name, fieldName, tpe, fieldTpe, required, default)
  }

  // we only handle two types of restrictions: Enumerations and string maxLength
  def nestedAttributeType(attributeElem: Elem): DataType = {
    val restriction = attributeElem \ "simpleType" \ "restriction"
    val base = (restriction \ "@base").headOption.map(_.text).map(DataType.fromName)
      .getOrElse(throw new Exception(s"Invalid attribute: $attributeElem"))
    val maxLength = (restriction \ "maxLength" \ "@value").headOption.map(_.text.toInt)
    if (base == DataType.String && maxLength.exists(_ == 1)) DataType.Character
    else { // not a character, assume enumeration
      val resultType = restriction.appInfo("className")
        .getOrElse(throw new Exception("enumeration type not allowed without className: " + attributeElem))
      val enums = (restriction \ "enumeration").map { e =>
        val stringValue = (e \ "@value").text
        val klassName = e.appInfo("className").getOrElse(stringValue)
        (stringValue, klassName)
      }.toSeq
      DataType.RestrictionType(base, resultType, Restriction.Enum(enums))
    }
  }

  def parseElementDefinition(elementElem: Node): ElementDefinition = {
    val minOccurs = (elementElem \ "@minOccurs").headOption.map(_.text.toInt).getOrElse(1)
    val maxOccurs = (elementElem \ "@maxOccurs").headOption.map(_.text)
      .map(m => if (m == "unbounded") None else Some(m.toInt))
      .getOrElse(Some(1))
    val fieldName = elementElem.appInfo("fieldName")
    (elementElem \ "@name").headOption.map(_.text).map { name =>
      val tpe = parseTypeAttribute(elementElem)
        .orElse((elementElem \ "complexType").headOption
          .map(e => parseComplexTypeContent(e, Map()))
          .map(DataType.NestedComplexType.apply _))
        .getOrElse(throw new Exception("Invalid element: " + elementElem))
      val additionalField = elementElem.appInfo("additionalField")
      val default =
        elementElem.attribute("default").map(_.text) orElse elementElem.appInfo("appDefault")
      SpecifiedElement(name, fieldName.getOrElse(name), additionalField, tpe, minOccurs, maxOccurs, default)
    }.orElse(
      (elementElem \ "@ref").headOption.map(_.text).map { refName =>
        ElementReference(refName, fieldName, minOccurs, maxOccurs, elementElem.appInfo("appDefault"))
      }
    ).getOrElse(throw new Exception("Invalid element: " + elementElem))
  }

  def parseSimpleContent(simpleContentElem: Node): Option[(ComplexTypeElements, Seq[SpecifiedAttribute])] = {
    val base = (simpleContentElem \ "extension" \ "@base").headOption.map(_.text).map(DataType.fromName)
    val fieldName =
      simpleContentElem.appInfo("fieldName").getOrElse("value")
    val attributes = (simpleContentElem \ "extension" \ "attribute")
      .map(e => parseSpecifiedAttribute(e.asInstanceOf[Elem]))
    base.map(b => (SimpleContent(b, fieldName), attributes))
  }

  def parseElement(sequenceElem: Node): Seq[ElementDefinition] = {
    (sequenceElem \ "element").map(parseElementDefinition).toSeq
  }

  def parseChoice(choiceElem: Node): Choice = {
    val choiceElements = choiceElem.flatMap(parseElement)
    val fieldName = choiceElem.appInfo("fieldName").getOrElse("value")
    val klassName = choiceElem.appInfo("className")
    val passThrough = choiceElem.appInfo("passThrough").map(_.toBoolean).getOrElse(false)
    Choice(choiceElements, fieldName, klassName, passThrough)
  }

  def parseSequenceChildren(sequenceElem: Node): Seq[SequenceChild] = {
    sequenceElem.child.collect {
      case e@Elem("xsd", "choice", _, _, _*)  => parseChoice(e)
      case e@Elem("xsd", "element", _, _, _*) => parseElementDefinition(e)
    }
  }

  def parseSequence(seqElem: Node): Sequence = {
    val variadic = seqElem.appInfo("variadic").map(_.toBoolean).getOrElse(false)
    val fieldName = seqElem.appInfo("fieldName")
    Sequence(parseSequenceChildren(seqElem), fieldName, variadic)
  }

  def parseComplexType(ctElement: Node, sharedSpecs: Map[String, AttributeGroup], isTopType: Boolean): ComplexType = {
    val name = ctElement.attributes("name").text
    val fileName = ctElement.appInfo("fileName")
    ComplexType(name, isTopType, parseComplexTypeContent(ctElement, sharedSpecs), fileName)
  }

  def parseComplexTypeContent(ctElement: Node, sharedSpecs: Map[String, AttributeGroup]): ComplexTypeContent = {
    val klassName = ctElement.appInfo("className")
      .orElse(Option(ctElement.attributes("name")).flatMap(_.headOption).map(_.text.capitalize))
      .getOrElse(throw new Exception("could not find className for: " + ctElement))
    val constructorName = ctElement.appInfo("constructorName").getOrElse(klassName)
    val importKlassName = ctElement.appInfo("import").map(_.toBoolean).getOrElse(true)
    val additionalImports = ctElement.appInfo("additionalImports").map(_.split(" ").toSeq).getOrElse(Seq[String]())
    val isPassThrough = ctElement.appInfo("passThrough").map(_.toBoolean).getOrElse(false)
    val simpleContent = (ctElement \ "simpleContent").headOption.flatMap(parseSimpleContent)
    val imports = if (importKlassName && !isPassThrough) additionalImports :+ klassName else additionalImports
    val isSingleton = ctElement.appInfo("singletonClass").map(_.toBoolean).getOrElse(false)
    if (simpleContent.isDefined) {
      (simpleContent.map {
        case (elems, attrs) =>
          ComplexTypeContent(attrs, elems, klassName, isPassThrough, constructorName, isSingleton, imports)
      }).get
    } else {
      val allAttributes =
        ctElement.child.flatMap {
          case e@Elem("xsd", "attributeGroup", _, _, _*) =>
            sharedSpecs(e.attributes("ref").text).attributes
          case e@Elem("xsd", "attribute", _, _, _*) =>
            Seq(parseSpecifiedAttribute(e.asInstanceOf[Elem]))
          case _ => Seq()
        }
      val allElements = (ctElement \ "all").flatMap(parseElement)
      val choiceElement = (ctElement \ "choice").headOption.map(parseChoice)
      val sequenceElement = (ctElement \ "sequence").headOption.map(parseSequence)
      val elements = choiceElement orElse sequenceElement getOrElse All(allElements)
      ComplexTypeContent(allAttributes, elements, klassName, isPassThrough, constructorName, isSingleton, imports)
    }
  }
}
